
\chapter{Implementation}
\label{chap:implementation}
\input{img/logo/logos.tex}

As per the requirements expounded upon in the introduction, the deliverable of
the project should be a finished software product. The software is written in
Python so as to integrate easily with the research group's ongoing software
projects around the Fleur code \cite{fleur}. These are chiefly the group's
materials science tool collection \texttt{masci-tools} \cite{masci-tools} ,
where also this project's code is hosted, and the 'Automated Interactive
Infrastructure and Database for Computational Science' (AiiDA) \cite{aiida}. The
product clients split into frontend users and code developers. In order to
accommodate this, the product is organized into three unidirectionally dependent
subpackages or -modules, see Figure \ref{fig:modules}.

An important design consideration was to account for unknown use cases. This has
been realized in each submodule by the decoupling of \textbf{interface} and
\textbf{implementation}. The interfaces do not rely on any specific input file
format, visualization method or package, unlike the implementations for a
specific task or \textbf{application}. The word 'application' in this section
denotes the band structure and density of states visualization, and for these,
implementations are provided.

This design choice was also one reason why the product does not reuse any of the
\texttt{masci-tools} routines which partly solve quite similar problems, but
seemed to be too specialized in an cursory code review. For these developers,
one added value of the project product could be to inspire the hopefully easy
integration into a common interface, where the current abstraction level could
serve as a starting point.

\begin{figure}[htb!]
    \centering
    \includegraphics[width=0.3\linewidth]{img/module_design.png}
    \caption{Module Design}
    \label{fig:modules}
\end{figure}

\section{HDF Preprocessor Module}
\label{sec:preprocessor-module}

\subsection{Interface}
\label{sec:preprocessor-interface}

This is the 'backend' of the tool. It is basically a file reader for the input
data, for example a Fleur simulation output. Supported formats are the
Hierarchical Data Format (HDF) \cite{hdf} for the band structure, and a simple
Fleur-specific comma-separated values (CSV) format for the density of states
(DOS).

The HDF format is basically a binary flexible container for all kinds of common
binary and text file formats, each of which constitutes a \texttt{Dataset}
inside the HDF file. The format supports metadata annotation and high-throughput
input/output (I/O). As a consequence, it is considered by some developers in
some application domains relying on numerical simulation codes, to be one
possible base for the establishment of common domain-specific rich data exchange
standards in order to increase code interoperability. These developers are in
the process of extending their codes' I/O capabilities towards that end.
However, HDF's flexibility comes at the price of a relatively complex Application
Programming Interface (API) as the keyhole for all operations.

The preprocessor module tries to hide that complexity by offering the
\texttt{Recipes} interface, see Figure \ref{fig:preprocessor}. A specific
application \texttt{Recipe} is a dictionary that aims to describe a complete
\href{https://en.wikipedia.org/wiki/Extract,_transform,_load}{Extract-Transform-Load}
(ETL) pipeline for one specific application. The 'extract' is the reading of a
dataset from HDF, the 'transform' a sequence of once-through functions applied
to the the dataset, and the 'load' the aggregation of all transformed datasets
into one runtime object that has all the methods for operations on the data that
are going to be used later on in the intended application.

The 'transform' and 'output' type methods are defined in hierarchical
\texttt{Transform} and \texttt{Output\_Type} classes, which sort them from
general to application-specific applicability. This structure is built using
Python's \texttt{AbstractBaseClass} (\texttt{ABC}) interface and multiple
inheritance. The advantages of the 'Recipes approach' are:
\begin{itemize}
\item All ETL processes for one application are collected in one simple list
    (the recipe), not locked in different code locations with conflicting
    contexts. In this list, entries can be sorted in any manner, e.g.
    alphabetical for perusal.
\item Recipes are de/serializable (can be read from and saved to disk) and thus be
    created and manipulated by code.
\item The ETL processes declared in this way can be easily reused across
    applications. A recipe can combine different output types into a new type.
\end{itemize}

The feature that enables this flexibility is \textbf{type introspection}: the
preprocessor processes the datasets listed in the recipe in the order of their
mutual dependencies as found in the used transform and output methods. When all
transformed datasets have been added to the object, all specified output types
are searched and all their methods and attributes added. Thus the output
object's type is defined at runtime, when the preprocessing is finished.

\begin{figure}[htb!]
    \centering
    \includegraphics[width=0.6\linewidth]{img/reader_flowchart4.png}
    \caption{The preprocessor module.}
    \label{fig:preprocessor}
\end{figure}

\lstinputlisting[
language=python,
style=code,
linerange=101-106
captionpos=t,
caption={Recipe \texttt{FleurBands} excerpt: dataset \texttt{BravaisMatrix}},
label=recipe
]{listings/recipes.py}


\subsection{Implementation for Band Structure Visualization}
\label{sec:preprocessor-implementation}

\begin{align}
  W^{\text{eff}}_{s,k,\nu} = \left( \frac{\sum\limits_{\substack{g \in \text{groups} \\ l \in \text{characters}}} n_{s,k,\nu,g,l} N_g}{\sum\limits_{\substack{g \in \text{all groups} \\ l \in \text{all characters}}} n_{s,k,\nu,g,l} N_g} \right) \left(W_{s,k,\nu}^{\text{unf}}\right)^\alpha
\end{align}

\(W^{\text{eff}}_{s,k,\nu}\) is the effective weight. The indices denote: \(s\)
spin, \(k\) point on \(k\)-path, \(\nu\) band, \(g\) group, \(l\) character.
\(n_{s,k,\nu,g,l}\) is the state-specific \(l\)-like charge. \(N_g\) denotes the
number of atoms in a group. \(W_{s,k,\nu}^{\text{unf}}\) is the unfolding weight
and \(\alpha\) it's exponent.


\textbf{TODO} describe how bandstructure data is preprocessed for visualization
including user selections AND optimizations

\section{Visualization Module \& Interactive Graphical Frontends}
\label{sec:visualization-module}

\textbf{TODO} Frontends: combine into one subsection when finished. usage will
be in user manual next section.

\subsection{Visualization Module Interface}
\label{sec:visualization-interface}

The Python visualization landscape \cite{python-visualization} abounds with a
plethora of plotting libraries for different application contexts and technology
stacks. Thus the project's visualization module first design objective is to
account for that by decoupling library use and modularizing applications. This
structure again is built using Python's \texttt{AbstractBaseClass}
(\texttt{ABC}) interface and multiple inheritance. Each application is
represented by an abstract base class that contains the common plotting method
signatures. Each plotting library is represented by an abstract base class that
contains library-specifics. An implementation inherits both from one or more
application- and a library-base class. See Fig. \ref{fig:visualization-module}
for clarification. Thus switching the library in a frontend should require
minimal adjustment, and a new application can be build using existing ones. The
second design objective is for the plotting methods to to hide all interactions
with the actual plotting library used under the hood, while the method
parameters only relates to the preprocessed data being plotted. Thus different
frontend implementations only need call one identical method for one plot and
receive the identical visualization with identical behavior.

\begin{figure}[htb!]
    \centering
    \includegraphics[width=1.0\linewidth]{img/pycharm_uml/matplot.png}
    \caption{Visualization Module Design: Example Structure for two applications
    \texttt{BandPlot} and \texttt{DOSPlot}, and two plotting libraries
    \texttt{matplotlib} and \texttt{bqplot}.}
    \label{fig:visualization-module}
\end{figure}

\subsection{Desktop Frontend Implementation}
\label{sec:desktop-frontend}

\subsection{Web Frontend Implementation}
\label{sec:web-frontend}

\textbf{TODO} describe tool selection process, refer to \cite{jw-notes}.




%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../report"
%%% End:

%  LocalWords:  subpackages submodule
